/*
 *
 * Copyright 2025 gRPC authors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */

use std::io::Write;
use std::{
    fs::File,
    path::{Path, PathBuf},
};

#[derive(Debug, Clone)]
pub struct Dependency {
    pub crate_name: String,
    pub proto_import_paths: Vec<PathBuf>,
    pub proto_files: Vec<String>,
}

impl From<&Dependency> for protobuf_codegen::Dependency {
    fn from(val: &Dependency) -> Self {
        protobuf_codegen::Dependency {
            crate_name: val.crate_name.clone(),
            proto_import_paths: val.proto_import_paths.clone(),
            // TODO: Is this useful to expose the following field? It's not used
            // by protobuf codegen.
            c_include_paths: Vec::new(),
            proto_files: val.proto_files.clone(),
        }
    }
}

/// Service generator builder.
#[derive(Debug, Clone)]
pub struct CodeGen {
    inputs: Vec<PathBuf>,
    output_dir: PathBuf,
    includes: Vec<PathBuf>,
    dependencies: Vec<Dependency>,
    // Rust import path for the generated message code. The gRPC service code
    // will use this to reference generated message structs. Defaults to "self".
    message_module_path: Option<String>,
    // Whether to generate message code, defaults to true.
    generate_message_code: bool,
}

impl CodeGen {
    pub fn new() -> Self {
        Self {
            inputs: Vec::new(),
            output_dir: PathBuf::from(std::env::var("OUT_DIR").unwrap()),
            includes: Vec::new(),
            dependencies: Vec::new(),
            message_module_path: None,
            generate_message_code: true,
        }
    }

    /// Sets whether to generate the message code. This can be disabled if the
    /// message code is being generated independently.
    pub fn generate_message_code(&mut self, enable: bool) -> &mut Self {
        self.generate_message_code = enable;
        self
    }

    /// Adds a proto file to compile.
    pub fn input(&mut self, input: impl AsRef<Path>) -> &mut Self {
        self.inputs.push(input.as_ref().to_owned());
        self
    }

    /// Adds a proto file to compile.
    pub fn inputs(&mut self, inputs: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        self.inputs
            .extend(inputs.into_iter().map(|input| input.as_ref().to_owned()));
        self
    }

    /// Sets the directory for the files generated by protoc. The generated code
    /// will be present in a subdirectory corresponding to the path of the
    /// proto file withing the included directories.
    pub fn output_dir(&mut self, output_dir: impl AsRef<Path>) -> &mut Self {
        self.output_dir = output_dir.as_ref().to_owned();
        self
    }

    /// Add a directory for protoc to scan for .proto files.
    pub fn include(&mut self, include: impl AsRef<Path>) -> &mut Self {
        self.includes.push(include.as_ref().to_owned());
        self
    }

    /// Add a directory for protoc to scan for .proto files.
    pub fn includes(&mut self, includes: impl Iterator<Item = impl AsRef<Path>>) -> &mut Self {
        self.includes.extend(
            includes
                .into_iter()
                .map(|include| include.as_ref().to_owned()),
        );
        self
    }

    /// Adds a Rust crate along with a list of proto files whose generated
    /// messages it contains.
    pub fn dependency(&mut self, deps: Vec<Dependency>) -> &mut Self {
        self.dependencies.extend(deps);
        self
    }

    /// Sets relative path of the module containing the generated message code.
    /// This is "self" by default, i.e. the service code expects the message
    /// structs to be present in the same module.
    pub fn message_module_path(&mut self, message_path: &str) -> &mut Self {
        self.message_module_path = Some(message_path.to_string());
        self
    }

    pub fn generate_and_compile(&self) -> Result<(), String> {
        // Generate the message code.
        if self.generate_message_code {
            protobuf_codegen::CodeGen::new()
                .inputs(self.inputs.clone())
                .output_dir(self.output_dir.clone())
                .includes(self.includes.iter())
                .dependency(self.dependencies.iter().map(|d| d.into()).collect())
                .generate_and_compile()
                .unwrap();
        }
        let crate_mapping_path = if self.generate_message_code {
            self.output_dir.join("crate_mapping.txt")
        } else {
            self.generate_crate_mapping_file()
        };

        // Generate the service code.
        let mut cmd = std::process::Command::new("protoc");
        for input in &self.inputs {
            cmd.arg(input);
        }
        if !self.output_dir.exists() {
            // Attempt to make the directory if it doesn't exist
            let _ = std::fs::create_dir(&self.output_dir);
        }

        if !self.generate_message_code {
            for include in &self.includes {
                println!("cargo:rerun-if-changed={}", include.display());
            }
            for dep in &self.dependencies {
                for path in &dep.proto_import_paths {
                    println!("cargo:rerun-if-changed={}", path.display());
                }
            }
        }

        cmd.arg(format!("--rust-grpc_out={}", self.output_dir.display()))
            .arg("--rust-grpc_opt=experimental-codegen=enabled");
        cmd.arg(format!(
            "--rust-grpc_opt=crate_mapping={}",
            crate_mapping_path.display()
        ));
        if let Some(message_path) = &self.message_module_path {
            cmd.arg(format!(
                "--rust-grpc_opt=message_module_path={}",
                message_path
            ));
        }

        for include in &self.includes {
            cmd.arg(format!("--proto_path={}", include.display()));
        }
        for dep in &self.dependencies {
            for path in &dep.proto_import_paths {
                cmd.arg(format!("--proto_path={}", path.display()));
            }
        }

        let output = cmd
            .output()
            .map_err(|e| format!("failed to run protoc: {}", e))?;
        println!("{}", std::str::from_utf8(&output.stdout).unwrap());
        eprintln!("{}", std::str::from_utf8(&output.stderr).unwrap());
        assert!(output.status.success());
        Ok(())
    }

    fn generate_crate_mapping_file(&self) -> PathBuf {
        let crate_mapping_path = self.output_dir.join("crate_mapping.txt");
        let mut file = File::create(crate_mapping_path.clone()).unwrap();
        for dep in &self.dependencies {
            file.write_all(format!("{}\n", dep.crate_name).as_bytes())
                .unwrap();
            file.write_all(format!("{}\n", dep.proto_files.len()).as_bytes())
                .unwrap();
            for f in &dep.proto_files {
                file.write_all(format!("{}\n", f).as_bytes()).unwrap();
            }
        }
        crate_mapping_path
    }
}

impl Default for CodeGen {
    fn default() -> Self {
        Self::new()
    }
}
