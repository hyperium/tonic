## Build

To build the Rust gRPC code generator plugin:

```sh
bazel build //src:protoc-gen-rust-grpc
```


## Usage Example

**Note:** It's generally recommended to use `tonic_protobuf_build::CodeGen`
and/or `protobuf_codegen::CodeGen` instead of invoking `protoc` directly. Direct
usage of `protoc` and checking in the generated code can lead to stale output if
the `protobuf` dependencies are upgraded later. Using the codegen APIs ensures
consistency with your dependency versions and simplifies regeneration.

```sh
# Build the plugin
bazel build //src:protoc-gen-rust-grpc

# Set the plugin path
PLUGIN_PATH="$(pwd)/bazel-bin/src/protoc-gen-rust-grpc"

# Run protoc with the Rust gRPC plugin
protoc \
  --plugin=protoc-gen-grpc-rust="$PLUGIN_PATH" \
  --rust_opt="experimental-codegen=enabled,kernel=upb" \
  --rust_out=./generated \
  --rust-grpc_out=./generated \
  routeguide.proto

# Optionally, you can add the plugin to the PATH and omit the --plugin flag.
export PATH="$(pwd)/bazel-bin/src/:$PATH"
```

## Available Options

These options are specific to the Rust gRPC plugin:

* `message_module_path=PATH` (optional): Specifies the Rust path to the module 
where Protobuf messages are defined. Use this when you plan to place the
generated message code in a different module than the service code.

  * Default: `self`
  * Example: If your messages are in `crate::pb::routeguide`, use 
  `message_module_path=crate::pb::routeguide`.
* `crate_mapping=PATH` (optional): Specifies the path to a crate mapping file
  generated by Bazel or another build system. You must pass the same mapping
  file to `rust_opt` and `rust-grpc_opt`. The file contains:
    ```
    <crate_name>\n
    <number of .proto files covered by that crate name>\n
    <import path of the first .proto file of the crate>\n
    ...
    <import path of the last .proto file of the crate>\n
    ```


## Language Server Support

To enable IDE features like code navigation and IntelliSense, generate 
`compile_commands.json` using [Hedron Compile Commands](https://github.com/hedronvision/bazel-compile-commands-extractor):

```sh
bazel run @hedron_compile_commands//:refresh_all
```

Then configure your C++ language server to use the generated 
`compile_commands.json`.
